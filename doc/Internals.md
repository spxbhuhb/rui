## Coding Conventions

Plugin source code function names follow these conventions:

- `init*` functions are called during instance initialization
- `build*` functions are called from `RuiClassBuilder.build` (maybe deeper in the chain), they do no return with
  anything
- `ir*` functions create and return with `IrElement` instances
- `trace*` functions add trace code when it is enabled in the plugin configuration by the `withTrace` option

## Definitions

A *component* is a class that extends `RuiFragment` and has its own *component state*. The
state may be empty. The compiler plugin generates components from *original functions*.
It is also possible to manually write a component, actually most low-level components
that interact with the underlying UI are written manually.

An *original function* is a function the UI programmer writes and is annotated with `@Rui`.
The compiler plugin turns original functions into a *components*.

A *structural* is a general building block used by *components* to build the structure of
the rendered UI. These are pre-defined by the Rui runtime: `RuiBlock`, `RuiWhen`,
`RuiLoop`. Structurals do not have a state, they use the state of the component they are
defined in when deciding how to render the UI.

A *fragment* is a *component* or a *structural*. Fragments are the building blocks of
the runtime Rui structure.

A *higher-order function* is an *original function* that has a function type parameter
annotated with `@Rui`.

A *parameter function* is a function passed as parameter to a *higher-order function*.

A *state variable* is a property of a *component*, part of the *component state*.

An *external state variable* is a *state variable* that is derived from a parameter of
the *original function*.

An *internal state variable* is a *state variable* that is derived from a variable defined
in the body of the *original function*.

The *runtime* is the `hu.simplexion.zakadabar:rui-runime` module. This contains base
classes and interfaces. It is important that this is a "static" runtime, there is no
engine running in the background to perform updates.

## External Patch

External patch functions update the external state variables of a component.

They are part of the parent component because they are call-site dependent.
Two different call sites may need two different external patch functions.
In the example below patching the two T1 components requires two different computations.

```kotlin
@Rui
fun test(i: Int) {
  T1(i + 1)
  T1(i + 2)
}
```

The compiler generates a function in the parent component for each call site.

Name of generated external patch functions is `ruiEpX` where `X` is the start offset
of the original function call the external patch belongs to.

```kotlin
fun ruiEp543(it: RuiT1, mask0: Long) {
  if (mask0 and 2 != 0) { // 2 is the mask for `this.value`
    it.p0 = this.value * 2
    it.ruiInvalidate(1) // 1 is the mask of `it.p0`
  }
}
```

## Bridge

The bridge connects Rui fragments with their representation in the underlying
UI. Low-level fragments (those that directly interact with the actual UI)
typically implement the `RuiBridge` interface and transform their internal
state into an actual UI state.

The `BT` type parameter of the bridge is a type in the underlying UI, typically
ancestor of all UI elements, such as `Node` in HTML or `View` in Android.

`ruiMount` and `ruiUnmount` functions get the bridge of the parent fragment
and use `add` and `remove` methods to add and remove themselves. Some bridges
also implement the `replace` method which makes it possible to replace a
fragment with another in place. This is used by `if` and `when`.

### Bridge dependent and bridge independent fragments

A bridge independent fragment is one that does not depend on the actual type
its bridge uses. On the other hand, a bridge dependent fragment is one
that uses the bridge in some very specific manner.

For example `RuiBlock` is a bridge independent fragment. It does not care
about what goes on, it just has a few children, and they will handle the
bridging themselves.

`Text` fragments are typically bridge dependent because each platform has its
own way to add constant text to the UI. In browsers for example you use
`document.createTextNode`.

Bridge independent fragments use type parameter for the bridge receiver type:

```kotlin
open class RuiBlock<BT>(
    override val ruiAdapter: RuiAdapter<BT>,
    vararg val fragments: RuiFragment<BT>
) : RuiFragment<BT> {
    // ...
}
```

Fragments generated by the plugin are bridge independent, thus usable with any
kind of adapter/bridge.

## Placeholders

A placeholder is an anchor the fragment uses to add/remove its children. We cannot
just add and then replace fragments because it is possible that the selected
fragment is a block or a loop. Those add an unknown number of children, thus simple
replace is impossible. For browsers the placeholder may be a simple `Node`
(Svelte uses a `Text`), for Android an actual Placeholder view exists.

Placeholders are created by the `RuiAdapter.createPlaceholder` function.

## Higher Order Functions

Transformation of higher order functions is rather complex because of the scopes involved. Unfortunately we can't
build on the actual Kotlin scopes (we transform a temporary runtime memory stack into a persistent object instance
tree).

The following example shows the complexity:

```kotlin
@Rui
fun ho(ph: Int, @Rui func: (pc: Int) -> Unit) {
  val vv = randomInt()
  func(ph * 2 + vv)
  func(ph * 3 + vv)
}

@Rui
fun test(p0: Int) {
  ho(p0) { p1 ->
    ho(p1) { p2 ->
      ho(p2) { p3 ->
        T1(p0 + p1 + p2 + p3)
      }
    }
  }
}
```

### Scopes

*start scope* State of the component in which the *parameter function* is defined.

*local scope* The state defined by the parameters of one *parameter function*.

*end scope* The state that is defined as the union of the *start scope* and all *local scopes*
between the *start scope* and the *end scope* (inclusive).

Example:

```kotlin
fun start(s1: Int) {      // start scope
  var s2: Int
  ho(s1) { p1 ->         // local scope
    ho(s2) { p2 ->     // end scope
      t1(p1 + p2)
    }
  }
}

fun ho(ho1: Int, @Rui func: (pc: Int) -> Unit) {
  var ho2: Int
}
```

States:

```
start scope    local scope    end scope

    s1             s1            s1
    s2             s2            s2
                   p1            p1
                                 p2
```

### Considerations

1. Higher-order components may perform calculations needed to properly patch the components deeper in the tree.
2. Components lower in the tree may access function parameters higher in the tree.
3. A higher-order component may use the parameter function more than once.

### Implicit Components

The parameter functions implicitly define components with the *end scope* as the component state.
We use classes from the runtime to create instances of these implicit components:

- RuiImplicit0
- RuiImplicit1
- RuiImplicitN

The number in the class name is the number of state variables the class stores. The first two should cover
most of the use cases why the last may be used for any number of parameters.

These classes **do not actually store** the state variables from the *start scope* and the intermediate *local scopes*.
Instead, they have a `ruiScope` property which stores the first upper level scope.

### Patching

Effective patching have to decide which components may be ignored. External patch passed to implicit fragments have to
know the dirty mask of their parent scopes to make these decisions possible.

This code has a limitation of 64 state variables, but I think we can live with that.

```kotlin
fun ruiEp123(it: RuiFragment, scopeMask: Long): Long {
  it as RuiImplicit
  if ((scopeMask and it.callSiteDependencyMask) == 0) return 0
  // do external patch stuff, updates it.ruiDirty0
  return scopeMask or (it.ruiDirty0 lsh numberOfStateVariables)
}

fun ruiPatch(scopeMask: Long) {
  val extendedScopeMask = fragment.ruiEp123(scopeMask)
  if (extendedScopeMask != 0) fragment.patch(extendedScopeMask)
}
```

`callSiteDependencyMask` bits belong to the state variables of the *end scope*. Any given call site will probably use
a subset of the state variables. We do not have to patch components that do not depend on changed variables.

`numberOfStateVariables` is the number of state variables in the parent scope.

For normal components (not higher order) `scopeMask` is simply the `ruiDirty0` of the start scope.